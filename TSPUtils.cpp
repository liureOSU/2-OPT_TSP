#include "TSPUtils.hpp"

/***************************************************************
*	fileInput
*	Input:	file name with info to be placed into a vector.
*
*	Output: a vector<vector<int>> of values in format (#,x,y).
****************************************************************/
vector<vector<int>> TSPUtils::fileInput(string fileName)
{
	vector<vector<int>> dataVector;
	int nextInt;
	string nString;
	istringstream iss;

	ifstream input;
	input.open(fileName);
	if (input) {

		while (getline(input, nString)) {
			vector<int> newRow;
			istringstream iss(nString);

			while (iss) {
				iss >> nextInt;
				newRow.push_back(nextInt);
			}

			newRow.pop_back();
			dataVector.push_back(newRow);
		}
	}
	else {
		cout << "File could not be opened." << endl;
	}
	return dataVector;
}

/************************************************************************
*	outputRows
*	Input:	a vector<vector<int>>.
*
*	Output: a text file, output.txt, with values from input 2D vector.
*************************************************************************/
void TSPUtils::outputRows(vector<vector<int>> displayVect)
{
	ofstream output;
	output.open("output.txt");

	for (int i = 0; i < displayVect.size(); i++) {
		for (int j = 0; j < displayVect.at(i).size(); j++) {
			output << displayVect.at(i).at(j) << " ";
		}
		output << "\n";
	}
	output.close();

}

/************************************************************************
*	outputRows
*	Input:	outputArray: an array of values
*	fileName: file name of output file.
*	size: size of input array.
*
*	Output: a text file with values in input array.
*************************************************************************/
void TSPUtils::outputRows(int * outputArray, int totalDistance, string fileName, int size)
{
	ofstream output;
	output.open(fileName);

	output << totalDistance << "\n";

	for (int i = 0; i < size; i++) {
		output << outputArray[i] << "\n";
	}

	output.close();
}

/************************************************************************
*	distance:
*	Input:	int** inputVect: a 2D int array containing set S with Sn = (n, xn, yn)
*	arrSize: number of rows of the input array.
*
*	Output: a 2D int array with calculated distances between each vertex.
*	The 2D array is upper triangular.
*	To get a distance between points x and y --> D(x,y):
*	if x < y, then distMatrix[x][y] will return distance.
*	if x > y, then reverse indices i.e. distMatrix[y][x].
*************************************************************************/
int** TSPUtils::distance(int ** inputVect, int arrSize)
{
	// Define 2D array that holds distance values.
	// distanceMatrix[x][y] = distance from x to y.
	int ** distanceMatrix = new int*[arrSize];
	for (int i = 0; i < arrSize; i++) {
		distanceMatrix[i] = new int[arrSize];
	}

	// Set all diagonals to distance = 0 and all other elements to -1.
	for (int i = 0; i < arrSize; i++) {
		for (int j = 0; j < arrSize; j++) {
			if (i == j) {
				distanceMatrix[i][j] = 0;
			}
			else {
				distanceMatrix[i][j] = -1;
			}
		}
	}

	// Calculate upper triangular distances.  Distances are rounded up or down
	// to nearest integer.
	for (int i = 0; i < arrSize; i++) {
		for (int j = i + 1; j < arrSize; j++) {
			double calcDistance = sqrt((inputVect[i][1] - inputVect[j][1]) *
				(inputVect[i][1] - inputVect[j][1]) + (inputVect[i][2] - inputVect[j][2]) * (inputVect[i][2] - inputVect[j][2]));
			distanceMatrix[i][j] = round(calcDistance);
		}
	}
	return distanceMatrix;
}

/************************************************************************
*	setStructs:
*	Input:	arrSize - number of vertices to check.
*
*	Output: an array of struct vertex.  Each vertex has a specific vertex
*	number and vertex.visited = false default.
*************************************************************************/
vertex* TSPUtils::setStructs(int arrSize)
{
	// Define an array of vertices.
	vertex * vertMatrix = new vertex[arrSize];

	// Each vertex gets a unique number and is set to visited = false.
	for (int i = 0; i < arrSize; i++) {
		vertex * var = new vertex;
		var->vertNumber = i;
		vertMatrix[i] = *var;
	}

	return vertMatrix;
}

/************************************************************************
*	greedyTSP
*	Input:	vertArray - the array of vertices generated by setStructs
*	arrSize - number of vertices to check.
*	distance - 2D array of distances generated by TSPUtils::distance.
*	&totalDistance - a distance variable which will be updated with path distance.
*
*	Output: an int array.  The values 1 ... i ... n is the path taken by
*	the greedy algorithm in order.
*	Also updates &totaldistance on completion.
*************************************************************************/
int* TSPUtils::greedyTSP(vertex * vertArray, int arrSize, int** distance, int &totalDistance)
{
	cout << "Greedy algorithm start." << endl;
	// Change starting vertex here.
	int startingVertex = arrSize / 2;

	// Initialize currentVertex and set visited to TRUE.
	int currentVertex = startingVertex;
	vertex * vertexPointer = &vertArray[currentVertex];
	vertexPointer->visited = true;

	int distanceCounter = 0;
	int vertexWithLowestDistance = currentVertex;

	// tourArray is used to store the traveled path. arrSize + 1 because the tour length
	// is stored at the front.
	int * tourArray = new int[arrSize];
	tourArray[0] = startingVertex;
	for (int i = 1; i < arrSize; i++) {
		int lowestDistance = INT_MAX;
		for (int trialVertex = 0; trialVertex < arrSize; trialVertex++) {

			// Check case that the vertex has not been visited yet.
			if (vertArray[trialVertex].visited == false) {

				// Case that the distance matrix needs to have inverted indices for true distance.
				if (distance[currentVertex][trialVertex] == -1) {
					if (distance[trialVertex][currentVertex] <= lowestDistance) {
						lowestDistance = distance[trialVertex][currentVertex];
						vertexWithLowestDistance = trialVertex;
					}
				}

				// Case that the distance matrix returns correct distance.
				else if (distance[currentVertex][trialVertex] <= lowestDistance) {
					lowestDistance = distance[currentVertex][trialVertex];
					vertexWithLowestDistance = trialVertex;
				}
			}
		}
		// Change lowest distance vertex to vertex.visited = TRUE.
		vertexPointer = &vertArray[vertexWithLowestDistance];
		vertexPointer->visited = true;

		distanceCounter += lowestDistance;
		currentVertex = vertexWithLowestDistance;

		// Push currentVertex to tourArray, keep track of tour order.
		tourArray[i] = currentVertex;
	}


	// Go back to starting vertex.
	if (distance[currentVertex][startingVertex] == -1) {
		distanceCounter += distance[startingVertex][currentVertex];
	}
	else {
		distanceCounter += distance[currentVertex][startingVertex];
	}

	totalDistance = distanceCounter;

	cout << "Greedy traveled distance: " << distanceCounter << endl;

	return tourArray;
}


/************************************************************************
*	twoOptTSP
*	size - size of presorted array.
*	&lowestDist - distance returned by nearest neighbor.
*	distances - 2D array of distances generated by TSPUtils::distance.
*	compTimeRemaining - current clock count of time usage.
*
*	Output: an int array.  The values 2 ... n is the path taken by
*	the optimized route in order.  Also updates &lowestDist with the
*	optimized distance from two opt.
*************************************************************************/
int * TSPUtils::twoOptTSP(int *presorted, int size, int &lowestDist, int **distances, int compTimeRemaining)
{
	int* existingRoute = presorted;
	int stopTime = 10000;
	std::chrono::steady_clock::time_point beginOpt = std::chrono::steady_clock::now();

	// Begin 2-OPT Algorithm.
startAgain:
	int bestDist = newDistance(existingRoute, size, distances);
	//determine time state

	bool useStart = 1;
	if (size > 5000) {
		size = 2000;
		useStart = 0;
	}

	// Iterate for each vertex in set.
	for (int i = 2; i < size - 2; i++) {

		// Time limit is set to 170s until self-termination of function.
		std::chrono::steady_clock::time_point optCheck = std::chrono::steady_clock::now();
		int optTimeRemaining = compTimeRemaining - std::chrono::duration_cast<std::chrono::milliseconds>(optCheck - beginOpt).count();
		bool keepGoing = (optTimeRemaining >= stopTime);

		// Uncomment this line to bypass time limit.
		//keepGoing = 1;

		// Compare distance from current vertex to all other vertices in set.
		if (keepGoing) {
			for (int j = i + 1; j < size - 2 && keepGoing; j++) {
				int * newRoute = twoOptSwitch(existingRoute, size, i, j);
				int newDist = newDistance(newRoute, size, distances);
				if (newDist < bestDist) {
					// If a newly calculated path is smaller, use new path as existingRoute and recalculate.
					std::cout << "\n" << newDist << endl;
					existingRoute = newRoute;
					bestDist = newDist;
					if (useStart) {
						goto startAgain;
					}
				}
				else {
					delete[] newRoute;
				}

				optTimeRemaining = compTimeRemaining - std::chrono::duration_cast<std::chrono::milliseconds>(optCheck - beginOpt).count();
				keepGoing = (optTimeRemaining >= stopTime);

			}

		}
		else {
			//terminate
		}
	}


	cout << "\n" << "Optimized travel distance: " << bestDist;
	lowestDist = bestDist;
	return existingRoute;
}

/************************************************************************
*	twoOptSwitch
*	Input:	presorted - an int array of vertices.
*	size - size of vertex array.
*	nodeX and nodeY - the positions between which to "flip" in two-opt
*	optimization.
*
*	Output: an int array of vertices with the two-optimized modification.
*************************************************************************/
int* TSPUtils::twoOptSwitch(int * presorted, int size, int nodeX, int nodeY)
{
	nodeX--;
	nodeY--;

	// testSort holds an int array of 2-opt modified path.
	int* testSort = new int[size];

	// From 0 to X, the order is the preserved between input and output.
	for (int i = 0; i < nodeX; i++) {
		testSort[i] = presorted[i];
	}

	// From X to Y, the order is reversed = 2-OPT.
	for (int i = nodeX; i <= nodeY; i++) {
		testSort[i] = presorted[nodeY + nodeX - i];
	}

	// From Y to n, the order is preserved.
	for (int i = nodeY + 1; i < size; i++) {
		testSort[i] = presorted[i];
	}

	return testSort;
}

/************************************************************************
*	newDistance
*	Input:	testSort - an array of vertices from twoOptSwitch output.
*	size - size of vertex array.
*	distances** - a list of
*
*	Output: the distance of the input path.
*************************************************************************/
int TSPUtils::newDistance(int * testSort, int size, int** distances)
{
	int newDist = 0;

	// Calculates the path distance for the input path.
	for (int i = 0; i < size - 1; i++) {
		if (distances[testSort[i]][testSort[i + 1]] == -1) {
			newDist += distances[testSort[i + 1]][testSort[i]];
		}
		else {
			newDist += distances[testSort[i]][testSort[i + 1]];
		}
	}

	// Add distance from start point to end point. (Close cycle)
	if (distances[testSort[0]][testSort[size - 1]] == -1) {
		newDist += distances[testSort[size - 1]][testSort[0]];
	}
	else {
		newDist += distances[testSort[0]][testSort[size - 1]];
	}

	return newDist;
}